{"version":3,"file":"physics-object.js","sourceRoot":"","sources":["../../../src/node/physics/physics-object.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventMap } from '@webtaku/event-emitter'\nimport Matter, { IChamferableBodyDefinition } from 'matter-js'\nimport { Container as PixiContainer } from 'pixi.js'\nimport { Collider, ColliderType } from '../../collision/colliders'\nimport { GameNode } from '../core/game-node'\nimport { isRenderableNode, RenderableNode } from '../core/renderable'\nimport { LocalTransform } from '../core/transform'\nimport { PhysicsWorld } from './physics-world'\n\nfunction createEllipseBody(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  options: IChamferableBodyDefinition = {},\n  // segLen은 \"인접 정점 사이의 목표 간격(px)\" 정도로 생각하면 됩니다.\n  segLen = 6\n): Matter.Body {\n  const rx = width / 2\n  const ry = height / 2\n\n  // 주변길이 ~ π(a+b) 근사 → 그 길이를 segLen 간격으로 쪼개서 정점 수 결정\n  const perimeterApprox = Math.PI * (rx + ry)\n  const segments = Math.max(12, Math.ceil(perimeterApprox / segLen))\n\n  const verts = Array.from({ length: segments }, (_, i) => {\n    const t = (i / segments) * Math.PI * 2\n    return { x: Math.cos(t) * rx, y: Math.sin(t) * ry }\n  })\n\n  // fromVertices는 로컬 기준이므로 x,y는 중심 위치로 넘깁니다.\n  return Matter.Bodies.fromVertices(x, y, [verts], options)\n}\n\nexport type PhysicsObjectOptions = {\n  collider: Collider\n  x?: number\n  y?: number\n  rotation?: number\n  fixedRotation?: boolean\n  velocityX?: number\n  velocityY?: number\n}\n\nexport class PhysicsObject<E extends EventMap = EventMap> extends RenderableNode<PixiContainer, E> {\n  #localTransform = new LocalTransform()\n  #matterBody: Matter.Body\n\n  constructor(options: PhysicsObjectOptions) {\n    super(new PixiContainer({ sortableChildren: true }))\n\n    const x = options.x ?? 0\n    const y = options.y ?? 0\n    const c = options.collider\n\n    const bodyOptions: IChamferableBodyDefinition = {\n      angle: options.rotation ?? 0,\n      velocity: { x: options.velocityX ?? 0, y: options.velocityY ?? 0 },\n    }\n\n    if (options.fixedRotation) {\n      bodyOptions.inertia = Infinity\n      bodyOptions.angularVelocity = 0\n    }\n\n    if (c.type === ColliderType.Rectangle) {\n      this.#matterBody = Matter.Bodies.rectangle(x, y, c.width, c.height, bodyOptions)\n    } else if (c.type === ColliderType.Circle) {\n      this.#matterBody = Matter.Bodies.circle(x, y, c.radius, bodyOptions)\n    } else if (c.type === ColliderType.Ellipse) {\n      this.#matterBody = createEllipseBody(\n        x, y, c.width, c.height, bodyOptions,\n        /* segLen= */ 6 // 더 매끄럽게 하고 싶으면 더 작게\n      )\n    } else if (c.type === ColliderType.Polygon) {\n      this.#matterBody = Matter.Bodies.fromVertices(x, y, [c.vertices], bodyOptions)\n    } else {\n      throw new Error('Invalid collider type')\n    }\n  }\n\n  protected override set parent(parent: GameNode<EventMap> | undefined) {\n    if (!(parent instanceof PhysicsWorld)) {\n      const actual = parent === undefined\n        ? 'undefined'\n        : parent.constructor?.name ?? typeof parent\n      throw new Error(`PhysicsObject parent must be PhysicsWorld, but got ${actual}`)\n    }\n    parent.addBody(this.#matterBody)\n    super.parent = parent\n  }\n\n  protected override get parent() {\n    return super.parent\n  }\n\n  override _updateWorldTransform() {\n    const mb = this.#matterBody\n\n    const pc = this._pixiContainer\n    pc.position.set(mb.position.x, mb.position.y)\n    pc.rotation = mb.angle\n\n    const lt = this.#localTransform\n    lt.x = mb.position.x\n    lt.y = mb.position.y\n    lt.rotation = mb.angle\n\n    const parent = this.parent\n    if (parent && isRenderableNode(parent)) {\n      this.worldTransform.update(parent.worldTransform, this.#localTransform)\n    }\n\n    super._updateWorldTransform()\n  }\n\n  override remove() {\n    (this.parent as PhysicsWorld)?.removeBody(this.#matterBody)\n    super.remove()\n  }\n\n  set x(v) { Matter.Body.setPosition(this.#matterBody, { x: v, y: this.#matterBody.position.y }) }\n  get x() { return this.#matterBody.position.x }\n\n  set y(v) { Matter.Body.setPosition(this.#matterBody, { x: this.#matterBody.position.x, y: v }) }\n  get y() { return this.#matterBody.position.y }\n\n  set rotation(v) { Matter.Body.setAngle(this.#matterBody, v) }\n  get rotation() { return this.#matterBody.angle }\n\n  set velocityX(v) { Matter.Body.setVelocity(this.#matterBody, { x: v, y: this.#matterBody.velocity.y }) }\n  get velocityX() { return this.#matterBody.velocity.x }\n\n  set velocityY(v) { Matter.Body.setVelocity(this.#matterBody, { x: this.#matterBody.velocity.x, y: v }) }\n  get velocityY() { return this.#matterBody.velocity.y }\n}\n"]}